from typing import Any, Dict, Mapping, Optional, Sequence

from tinytable import Table
import sqlalchemy as sa
from sqlalchemy.engine import Engine
from sqlalchemize.select import select_records_all
from sqlalchemize.features import get_table, get_table_names, primary_key_names
from sqlalchemize.create import create_table
from sqlalchemize.type_convert import get_sql_types
from tinytim.rows import row_dicts_to_data
from tinytim.data import column_names


class SqlTable(Table):
    def __init__(
        self,
        name: str,
        engine: Engine,
        primary_key: Optional[str] = None,
        data: Mapping[str, Sequence] = {},
        schema: Optional[str] = None
    ) -> None:
        self.name: str = name
        self.engine: Engine = engine
        self.schema: None | str = schema
        self.data: Dict[str, list]
        table_names = get_table_names(engine, schema)
        if name in table_names:
            self.pull()
        elif name not in table_names and primary_key is not None:
            self.data = {name: list(col) for name, col in data.items()}
            if primary_key in column_names(self.data):
                self.primary_key = primary_key
            else:
                raise ValueError('primary_key must match a column name')
        else:
            raise ValueError('primary_key cannot be None when sql table does not exist yet.')

    def pull(self) -> None:
        """Pull table data from sql database table into SqlTable"""
        table = get_table(self.name, self.engine, self.schema)
        records = select_records_all(table, self.engine)
        self.data = row_dicts_to_data(records)
        self.primary_key = primary_key_names(table)[0]

    def push(self)  -> None:
        """Push SqlTable changes to sql database table."""
        # check if table exists in sql database
        if self.name in get_table_names(self.engine, self.schema):
            # check for changes between SqlTable and database table
            ...
        else:
            # create sql database table
            create_table(
                self.name,
                column_names(self.data),
                get_sql_types(self.data),
                self.primary_key,
                self.engine,
                self.schema)
            # insert SqlTable rows
            ...
        

def read_sql_data(
    table_name: str,
    engine: Engine,
    schema: Optional[str] = None
) -> Dict[str, list]:
    table = get_table(table_name, engine, schema)
    records = select_records_all(table, engine)
    return row_dicts_to_data(records)


def read_sql_table(
    table_name: str,
    engine: Engine,
    primary_key: Optional[str],
    schema: Optional[str] = None
) -> SqlTable:
    data = read_sql_data(table_name, engine, schema)
    return SqlTable(table_name, engine, primary_key, data, schema)



